<!DOCTYPE html>
<html>
<head>
<title>CS 111 Scribe Notes: Lecture #1</title>
	<meta charset="utf-8">
    <!-- <meta name="format" content="complete"> -->
    <style>
    body {
        text-align: center;
    }
    table, th, td {
        border: 1px solid black
    }
    #page-wrap {
        text-align: left;
        width: 800px;
        margin: 0 auto; 
    }
    #table-wrap {
        text-align: center;
        width: 800px;
        margin: 0 auto;
    }
    </style>
</head>


<body>

<div id="page-wrap">

<h1>Notes: CS 111 - Winter 2015</h1>

<h1>Ky-Cuong L. Huynh and Kelly Hosokawa</h1>

<h1>UCLA Class of 2017</h1>

<h2>Lecture #1: 5 January 2014</h2>

<h3>Magical Grep</h3>

<p>Eggert showing some output: </p>

<pre><code>$ ls -l big 
-rw-rw-r-- 1 eggert faculty 9223372036854775000 Oct 6 11:41 big
$ 
</code></pre>

<p>permissions, 1 hard link, ..., ..., size</p>

<p>~10<sup>19</sup> bytes in size</p>

<p>Look for char 'x' in it. </p>

<pre><code>$ grep x big
$ 
</code></pre>

<p>No matches. Then he timed it: </p>

<pre><code>$ time grep x big 
real 0m009s
</code></pre>

<p>Just 9 milliseconds. Whaaat?
That's waaay too fast:
10<sup>19</sup> bytes / 10<sup>{</sup>-2} seconds =&gt; 10<sup>21</sup> bytes/second
 =&gt; 8 * 10<sup>21</sup> bits/second
 =&gt; 8 Zb/second (zetabits/second)</p>

<p>Eggert is encouraging us to read xkcd What If #31, haha,
which asks what is the entire bandwidth of the Internet?
The current estimate is 167 Tb/second (Terabits/second).
Then, the comic asks how we can move data faster? </p>

<p>Here, at UCLA, we have that problem too. Solution:
Use the Sneakernet. Move the hard disks physically.
So if we use all of the US freight industry (UPS, USPS, FedEx, etc.)
to move a bunch of MicroSD cards, then we can move
0.5 Zb/s. How was grep 16 times faster? It cheated. </p>

<p>The file wasn't actually that big; we pretended to
make it that big, enough to fool all of the standard
Unix utilities. Grep was smarter: "in all of the places
you cheated, there are no x's". </p>

<p>Say we did: </p>

<pre><code>$ echo x &gt;&gt; big
</code></pre>

<p>Then: </p>

<pre><code>$ grep x big    
Binary file 'big' matches
</code></pre>

<p>We're going to learn and understand how things work,
especially operating systems. It is essential. </p>

<p>"This is the pep talk here, where we try to encourage
more people to watch the course. Maybe I shouldn't have done that."
Haha. xD </p>

<h3>Course Administration</h3>

<p>What we should know (listed for the transfers): </p>

<p>CS 32: data structures &amp; algorithms
CS 33: assembly code, caches, ALUs, etc.
CS 35L: Make, GDB, threads, etc. </p>

<p>Why did we get 35L? 111 was too hard, so they
made the first 20% of it into 35L. </p>

<p>Eggert also recommends: </p>

<p>CS 131 (programming languages): how languages work
CS 151B (computer systems architecture): CS 33 on steroids
CS 118 (networking)</p>

<p>The faculty had a big "arm-wrestling contest",
and Eggert lost, so 111 is actually a pre-requisite
for them. Problem: They require each other for
understanding. We get to learn on the fly. </p>

<p>Faculty fought hard to make it a 5-unit course: </p>

<p>As reported to the dean:</p>

<div id="table-wrap">
<table>
  <tr>
      <!-- TODO: Center text in cell; move tables side-by-side -->
    <td>Lecture</td>
    <td>4 Hours</td> 
  </tr>
  <tr>
    <td>Lab</td>
    <td>2 Hours</td> 
  </tr>
  <tr>
    <td>Outside Study</td>
    <td>9 Hours</td> 
  </tr>
</table>

<p>In reality:</p>

<table>
  <tr>
    <td>Lecture</td>
    <td>3.5 Hours</td> 
  </tr>
  <tr>
    <td>Lab</td>
    <td>1.7 Hours</td> 
  </tr>
  <tr>
    <td>Outside Study</td>
    <td>20 Hours</td> 
  </tr>
</table>
</div>

<p>His recommendation: No procrastination. </p>

<p>Course organization: 17 lectures</p>

<p>1/9 of grade: 1 midterm, 100 minutes, open notes (esp. assignment printouts),
during lecture midway through quarter</p>

<p>2/9 of grade: 1 final, 180 minutes, open notes also </p>

<p>1/3 of grade: 4 labs: done with partners
 1. Write a shell (with performance features).
 It's different from the others. It's designed
 to make everyone code a lot of C, and get
 really good at debugging it too. It comes in 3 parts,
 which we will turn in separately. We're expected
 to be able to break up the other assignments on our own.
 2. Kernel hacking, like write a driver
 3. Write a file system
 4. Distributed.
 "The labs are based on real Linix. No toy operating systems.
 Go take classes at Berekley."</p>

<p>2/15 of grade: 2 minilabs: done solo
 1. Scheduling
 2. Virtual memory</p>

<p>1/12 of grade: Design problem (with partner)
 1. Pick a design problem from one of the labs,
 with consultation from TA
 2. Write up a report, etc. </p>

<p>1/20 of grade: Scribe notes (in groups up to 4)
 Use HTML 5 or 4.01, <em>validated</em>
 or else points lost. He wants scribe notes
 that will "past the test of time". Points loss:
 confusing, ugly, out-of-order; make Eggert look
 like a genius, like it's the Feyman Lectures
 Go to validator.w3c.org
 Sign-up during break in class.
 Due 1 week after lecture. </p>

<p>1/15 of grade: A 2-to-3 page "research" paper,
 Really a review paper on some topic
 related to operating systems. We'll
 read papers and articles on them, and
 then write a report. We can suggest one of
 our own too. </p>

<p>Lateness penalty:
1% penalty for (0, 1) days late
2% penalty for (1, 2) days late
4% penalty for (2, 3) days late, etc. </p>

<p>Drop-dead date: 13 March, the last day
of instruction: no assignments accepted
after this day. </p>

<p>"I've been in meetings with lawyers trying
to defend the students, and I've beaten the lawyers
every time."</p>

<p>"I have been known to seed the Internet with wrong answers."</p>

<p>Email a TA or Eggert if unsure after something. </p>

<p>No formal curve. His finals are North Campus'y,
combining many ideas from multiple places, so the
problems tend to be hit-or-miss. He shoots for a mean
of 50%. Often, it's above or below that. A typical
GPA for 111 is a 3.0, meaning a ~(B-). </p>

<p>Textbook (which is apparently a controversial choice):
<em>Principles of Computer System Design</em>. This is
MIT's computer system design course. The authors
are stars of OS design. The grad students write the book
for them. This book has everything, and doesn't really
dilineate into discrete chapters. </p>

<p>Eggert will not limit himself to what is in the book,
though he will try to keep them related. Even the assignment-lectures
link is loose. The discussion sections are actually very important,
as the TAs have been informed of all the gritty details. </p>

<h3>Operating Systems</h3>

<!-- TODO: Link to the referenced articles -->
<p>Articles related to OS':</p>

<p>"Red Star 3.0: North Korea launches its own OS";
 2014-12-31 Sky News (UK)</p>

<p>"Crouton for Chromebooks: Run Ubuntu in a browser tab"
 2014-12-28 lilputing
 (Doesn't work with a diff. GNU/Linux distro. though;
 find out why!)</p>

<p>"Samsung says new (2015) TVs will run Tizen [formerly LiMo]"
 CNET 2015-01-05</p>

<p>Quotes on OS': </p>

<p>Marina Weisbard, leader of Geman Pirate Party (they like piracy):
"We don't offer a ready-made programme, but an entire operating system."
 - The Economist 2013-01-15, p. 19 </p>

<p>Operating systems are connected to politics, undreamed of before. </p>

<h4>Definition: System</h4>

But what is a system? 

We can turn to an Oxford English Dictionary from 1928 to find 
a traditional, pre-computer definition:

<p>
I. An organized or connected group of objects.
II. A set of principles, etc., a scheme, method. 

Just as interesting is the etymology. "System" comes from the Greek
σύστημα, (transliterated as "sýstima"), meaning "organized whole,
government, constitution". The idea of a system is thus ancient. 
Even the roots of sýstima mean "set up with". Marina in the above 
quote is appealing to this ancient meaning. 
</p>

<p>Let's see another definition, this one from the course 
textbook, from §1.A.2: </p>

<p>"A set of interconnected components that has a
specified behavior observed at the interface with its environment."</p>

<p>Let's move to the modern era by examining the definition 
for "operating system" specifically. about from from Bill Gates' personal
encyclopedia, Encarta (2007)?</p>

<p>"Master control program in a computer"</p>

<p>By this definition, the entity in control is the one 
that matters, a definition fit for Microsoft.</p>

<p>Yet another definition comes from the American Heritage dictionary
(the most conservative dictionary, in its 4th edition from 2000): </p>

<p>"Software designed to control the hardware of a specific 
data-processing system in order to allow users and application 
programs to make use of it."</p>

<p>This is a very traditional definition. It is also obsolete. 
Operating systems are no longer necessarily hardware-specific. 
Even so, user and applications still matter. 

<p>Finally, from Wikipedia (page id: 640779030, 2015-01-03): </p>

<p>"Software that manages computer hardware and software
resources and provides common services for computer programs"</p>

<p>Note how "control" has become "manage" and the appearance
of "resources". Resource-management will be of great importance.
As for "common services", it comes back to how we implement
that system's interface, e.g. any program can ask the OS to
translate UI text to Spanish for it. We want to avoid duplication.
The overall goal here is <em>clarity</em>, as few as lines of code as possible. </p>

<p>"How can we make our systems obvious and clear?"</p>

<h3>Problems in System Design</h3>

<p>Common Systems Problems: </p>

<h4>1. Incommensurate scaling</h4>

<p>Well known in physical engineering designs.
Example: a 12-foot tall human would need a
a modified skeleton. Even stretching in all
3 directions would not work. We'd be 8 times as heavy
and 2 times as tall, but our bone strength
grows as the square of their cross-section. </p>

<p>We are hitting <em>diseconomies of scale</em>, where
things get more expensive per unit. Example:
an 8-port gigabit router is $100, but a 48-port
gigabit router is thousands of dollars. It's a
<em>star network</em> where the number of possible combinations
of connections grows as the square. </p>

<p>Contrast with: <em>economies of scale</em>, as with
the pin factory from Adam Smith's <em>Wealth of Nations</em>.
It's more efficient to have someone specialize,
invest capital for eqipment, and make
many pins rather than everyone else produce their own.
We need to look for <em>both</em> of these phenomena into
account when we scale our systems. Otherwise, they
cause breakage or waste (e.g., too many pins). </p>

<h4>2. Emergent properties</h4>

<p>These are properties that only become appparent
<em>qualitatively</em>. "Things just happen" as the system
gets bigger, and we didn't predict them. We're looking
for things that look like no big deal or maybe don't even
exist or are noticeable at a small scale, but break things
at a large scale.</p>

<p>20 years ago, we got the latest and fastest
Internet connections. The goal: Do homework faster.
Instead, they pirated songs, as with Napster.
UCLA got a huge amount of cease-and-desist letters.
At one point, more than 80% of the network traffic was
pirated materials. </p>

<p>Another example, the Tacoma Narrows bridge: They forgot
about resonant frequencies, in this case from the wind.
Every civil engineer gets an earful of this now. </p>

<h4>3. Propagation of effects</h4>

<p>Operating systems are digital, not analog.
The smallest thing can make an operating system crash.
We <em>think</em> we have some well-designed OS with boundaries
between components. Effects may still cross boundaries
and wreck things. </p>

<p>Example: A file system takes requests like a:\b\c and gives
you the file: </p>

<pre><code>cat a:\b\c
</code></pre>

<p>Somewhere else, we have an encoding for Japanese characters,
which cannot fit in one byte (more than 256 chars). </p>

<p>ASCII has the top, first bit be 0.
Japanese will have the top bit be 1, and have two bytes.
This gives us 2<sup>15</sup> combinations, and so we can handle
Japanese now. </p>

<p>Say we had: </p>

<pre><code>cp a:\b\c d:[Japanese]
</code></pre>

<p>Giving him a message like: </p>

<pre><code>&quot;cannot create directory [Japanese]&quot;
</code></pre>

<p>What happened? The top bit of the second byte
had a 0, and the rest of it looked like a backslash.
This happened with an early version of Windows.
To fix this, Microsoft had to break down the boundary
between the encoding and the file system and make things
more complicated. </p>

<h4>4. Trade-offs</h4>

<p>We face all the previous problems, and we start trying
to solve them, only to find that that we make other
problems worse. </p>

<p>Example: sorting algorithms. Bubble sort
is faster (than heap sort or mergesort for small-enough datasets,
but doesn't scale the way they do. </p>

<h4>5. Complexity</h4>

<p>This is the problem special to CS. </p>

<p>Consider Moore's Law: Complexity doubles every 18-24 months.
(for the cheapest design point; it doesn’t hold for more
expensive CPUs, say). Originally, the law Gordon Moore
formulated referred to the number of transistors on a chip.
Eggert said Moore's Law is petering out, but he said
that 10 years ago too. </p>

<p>Our computers are getting more complicated, but
we designers are not. </p>

<p>Consider Kryder's Law: Disk drive capacity is also
growing exponentially. Eggert's first home computer had
a 1 GB hard drive in 1992 for $1,000. </p>

<p>We need to build systems that work, and that we <em>understand</em>
despite their immense complexity. The biggest problem we're
going to face is how to manage these enormously complicated
objects, and make them work-well. </p>

</div>
</body>
</html>
